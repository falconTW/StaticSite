[
{
	"uri": "http://falcontw.me/codingquestions/",
	"title": "Coding Questions",
	"tags": [],
	"description": "",
	"content": " \nLeetcode / Hackerrank. "
},
{
	"uri": "http://falcontw.me/codingquestions/array/searchinrotatedsortedarray/",
	"title": "SearchInRotatedSortedArray",
	"tags": [],
	"description": "",
	"content": " Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\nYou are given a target value to search. If found in the array return its index, otherwise return -1.\nYou may assume no duplicate exists in the array.\nYour algorithm\u0026rsquo;s runtime complexity must be in the order of O(log n).\nExample 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1  Solution 1 int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0; int right = nums.size() - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u0026lt; nums[right]) { if (target \u0026gt; nums[mid] \u0026amp;\u0026amp; target \u0026lt;= nums[right]) { left = mid + 1; } else { right = mid - 1; } } else { if (target \u0026gt;= nums[left] \u0026amp;\u0026amp; target \u0026lt; nums[mid]) { right = mid - 1; } else { left = mid + 1; } } } return -1; } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/insertinterval/",
	"title": "InsertInterval",
	"tags": [],
	"description": "",
	"content": " Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\nYou may assume that the intervals were initially sorted according to their start times.\nExample 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.  Solution 1 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; insert(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals, vector\u0026lt;int\u0026gt;\u0026amp; newInterval) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; int cur = 0; for (int i = 0; i \u0026lt; intervals.size(); ++i) { if (intervals[i][1] \u0026lt; newInterval[0]) { result.push_back(intervals[i]); cur++; } else if (intervals[i][0]\u0026gt;newInterval[1]) { result.push_back(intervals[i]); } else { newInterval[0] = min(intervals[i][0], newInterval[0]); newInterval[1] = max(intervals[i][1], newInterval[1]); } } result.insert(result.begin() + cur, newInterval); return result; } };  "
},
{
	"uri": "http://falcontw.me/codingquestions/array/mergeinterval/",
	"title": "MergeInterval",
	"tags": [],
	"description": "",
	"content": "Given a collection of intervals, merge all overlapping intervals.\nExample 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.  classSolution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; if(intervals.empty()){ return result; } sort(intervals.begin(),intervals.end(),[](const vector\u0026lt;int\u0026gt; \u0026amp;a,vector\u0026lt;int\u0026gt; \u0026amp;b){ return a[0]\u0026lt;b[0]; }); result.push_back(intervals[0]); for(int i=1;i\u0026lt;intervals.size();i++){ if(result.back()[1]\u0026lt;intervals[i][0]){ result.push_back(intervals[i]); }else{ result.back()[1]=max(result.back()[1],intervals[i][1]); } } return result; } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/dynamicprogramming/regularexpressionmatch/",
	"title": "RegularExpressionMatch",
	"tags": [],
	"description": "",
	"content": " Given an input string (s) and a pattern (p), implement regular expression matching with support for \u0026lsquo;.\u0026rsquo; and \u0026lsquo;*\u0026lsquo;.\n\u0026rsquo;.\u0026rsquo; Matches any single character. \u0026lsquo;*\u0026rsquo; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial).\nNote:\ns could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1:\nInput: s = \u0026quot;aa\u0026quot; p = \u0026quot;a\u0026quot; Output: false Explanation: \u0026quot;a\u0026quot; does not match the entire string \u0026quot;aa\u0026quot;. Example 2: Input: s = \u0026quot;aa\u0026quot; p = \u0026quot;a*\u0026quot; Output: true Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes \u0026quot;aa\u0026quot;. Example 3: Input: s = \u0026quot;ab\u0026quot; p = \u0026quot;.*\u0026quot; Output: true Explanation: \u0026quot;.*\u0026quot; means \u0026quot;zero or more (*) of any character (.)\u0026quot;. Example 4: Input: s = \u0026quot;aab\u0026quot; p = \u0026quot;c*a*b\u0026quot; Output: true Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches \u0026quot;aab\u0026quot;. Example 5: Input: s = \u0026quot;mississippi\u0026quot; p = \u0026quot;mis*is*p*.\u0026quot; Output: false  Solution 1  P[i][j] = P[i - 1][j - 1], if p[j - 1] != \u0026lsquo;*\u0026rsquo; \u0026amp;\u0026amp; (s[i - 1] == p[j - 1] || p[j - 1] == \u0026lsquo;.\u0026rsquo;); P[i][j] = P[i][j - 2], if p[j - 1] == \u0026lsquo;*\u0026rsquo; and the pattern repeats for 0 times; P[i][j] = P[i - 1][j] \u0026amp;\u0026amp; (s[i - 1] == p[j - 2] || p[j - 2] == \u0026lsquo;.\u0026rsquo;), if p[j - 1] == \u0026lsquo;*\u0026rsquo; and the pattern repeats for at least 1 times.  classSolution { public: bool isMatch(string s, string p) { int m = s.size(); int n = p.size(); vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(m + 1, vector\u0026lt;bool\u0026gt;(n + 1, false)); dp[0][0] = true; for (int i = 1; i \u0026lt;= n; ++i) { if (p[n - 1] == \u0026#39;*\u0026#39;) { dp[0][i] = dp[0][i - 1]; } } for (int i = 0; i \u0026lt;= m; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { if (p[j - 1] == \u0026#39;*\u0026#39;\u0026amp;\u0026amp; j \u0026gt; 1) { dp[i][j] = dp[i][j - 2] || (i \u0026gt; 0 \u0026amp;\u0026amp; (s[i - 1] == p[j - 2] || p[j - 2] == \u0026#39;.\u0026#39;) \u0026amp;\u0026amp; dp[i - 1][j]); } else { dp[i][j] = dp[i - 1][j - 1] \u0026amp;\u0026amp; (s[i - 1] == p[j - 1] || p[j - 1 == \u0026#39;.\u0026#39;]); } } } return dp[m][n]; } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/dynamicprogramming/wildcardmatching/",
	"title": "WildCardMatching",
	"tags": [],
	"description": "",
	"content": " Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for \u0026lsquo;?\u0026rsquo; and \u0026lsquo;*\u0026lsquo;.\n\u0026rsquo;?\u0026rsquo; Matches any single character. \u0026lsquo;*\u0026rsquo; Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial).\nNote:\ns could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *. Example 1:\nInput: s = \u0026quot;aa\u0026quot; p = \u0026quot;a\u0026quot; Output: false Explanation: \u0026quot;a\u0026quot; does not match the entire string \u0026quot;aa\u0026quot;. Example 2: Input: s = \u0026quot;aa\u0026quot; p = \u0026quot;*\u0026quot; Output: true Explanation: '*' matches any sequence. Example 3: Input: s = \u0026quot;cb\u0026quot; p = \u0026quot;?a\u0026quot; Output: false Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'. Example 4: Input: s = \u0026quot;adceb\u0026quot; p = \u0026quot;*a*b\u0026quot; Output: true Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring \u0026quot;dce\u0026quot;. Example 5: Input: s = \u0026quot;acdcb\u0026quot; p = \u0026quot;a*c?b\u0026quot; Output: false  Question 1 我們使用一個二維 dp 數組，其中 dp[i][j] 表示 s中前i個字符組成的子串和p中前j個字符組成的子串是否能匹配。 大小初始化為 (m+1) x (n+1)，加1的原因是要包含 dp[0][0] 的情況，因為若s和p都為空的話，也應該返回 true 所以也要初始化 dp[0][0] 為 true。還需要提前處理的一種情況是，當s為空，p為連續的星號時的情況。由於星號是可以代表空串的，所以只要s為空 那麼連續的星號的位置都應該為 true，所以我們現將連續星號的位置都賦為 true。 然後就是推導一般的狀態轉移方程了，如何更新 dp[i][j]，首先處理比較 tricky 的情況，若p中第j個字符是星號，由於星號可以匹配空串，所以如果p中的前 j-1 個字符跟s中前i個字符匹配成功了（ dp[i][j-1] 為true）的話，那麼 dp[i][j] 也能為 true。或者若p中的前j個字符跟s中的前i-1個字符匹配成功了（ dp[i-1][j] 為true ）的話，那麼 dp[i][j] 也能為 true（因為星號可以匹配任意字符串，再多加一個任意字符也沒問題）。若p中的第j個字符不是星號，對於一般情況，我們假設已經知道了s中前 i-1 個字符和p中前 j-1 個字符的匹配情況（即 dp[i-1][j-1] ），那麼現在只需要匹配s中的第i個字符跟p中的第j個字符，若二者相等（ s[i-1] == p[j-1] ），或者p中的第j個字符是問號（ p[j-1] == '?' ） class Solution { public: bool isMatch(string s, string p) { int m = s.size(); int n = p.size(); //Let dp denotes whether s[i] matches p[j] or not. vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(m + 1, vector\u0026lt;bool\u0026gt;(n + 1, false)); dp[0][0] = true; for (int i = 1; i \u0026lt;= n; ++i) { if (p[n - 1] == '*') { dp[0][i] = dp[0][i - 1]; } } for (int i = 1; i \u0026lt;= m; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { if (p[j - 1] == '*') { dp[i][j] = dp[i][j - 1] || dp[i - 1][j]; } else { dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == '?') \u0026amp;\u0026amp; dp[i - 1][j - 1]; } } } return dp[m][n]; } };  "
},
{
	"uri": "http://falcontw.me/codingquestions/array/rotateimage/",
	"title": "RotateImage",
	"tags": [],
	"description": "",
	"content": " You are given an n x n 2D matrix representing an image.\nRotate the image by 90 degrees (clockwise).\nNote:\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\nExample 1: Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ]  Example 2: Given input matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], rotate the input matrix in-place such that it becomes: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ]  Soulution 2 To achieve 90degrees clockwise rotation, two steps are enough.\nFirst, mirroring element accodring diagnal line.\nSecond, reverse each row.\nclassSolution { public: void rotate(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { for (int i = 0; i \u0026lt; matrix.size(); ++i) { for (int j = i+1; j \u0026lt; matrix[i].size(); ++j) { if (i == j) { continue; } int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } for (int i = 0; i \u0026lt; matrix.size(); ++i) { int left = 0; int right = matrix[i].size() - 1; while (left \u0026lt;= right) { int temp = matrix[i][left]; matrix[i][left] = matrix[i][right]; matrix[i][right] = temp; left++; right--; } } } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/array/wordsearchii/",
	"title": "WordSearchII",
	"tags": [],
	"description": "",
	"content": " Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where \u0026quot;adjacent\u0026quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: Input: board = [ ['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v'] ] words = [\u0026quot;oath\u0026quot;,\u0026quot;pea\u0026quot;,\u0026quot;eat\u0026quot;,\u0026quot;rain\u0026quot;] Output: [\u0026quot;eat\u0026quot;,\u0026quot;oath\u0026quot;] Note: All inputs are consist of lowercase letters a-z. The values of words are distinct.  Solution 1 This question is similar to Word search, however, this question want further gather all the words in the board.\nTo get better time complexity, iterative ways are not accepted, we need to transform the input into prefix tree first then do word search.\nclassSolution { public: struct TrieNode { TrieNode *child[26]; string str; bool isEndOfWord; TrieNode() :str(\u0026#34;\u0026#34;) { for (auto \u0026amp;c : child) { c = NULL; } } }; void InsertTrieNode(TrieNode* root, string str) { TrieNode* p = root; for (auto \u0026amp;c : str) { if (p-\u0026gt;child[c - \u0026#39;a\u0026#39;] == NULL) { p-\u0026gt;child[c - \u0026#39;a\u0026#39;] = new TrieNode(); } p = p-\u0026gt;child[c - \u0026#39;a\u0026#39;]; } p-\u0026gt;str = str; } vector\u0026lt;string\u0026gt; findWords(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, vector\u0026lt;string\u0026gt;\u0026amp; words) { vector\u0026lt;string\u0026gt; res; if (words.empty() || board.empty() || board[0].empty()) { return res; } vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(board.size(), vector\u0026lt;bool\u0026gt;(board[0].size(), false)); TrieNode* root = new TrieNode(); for (auto \u0026amp;s : words) { InsertTrieNode(root, s); } for (int i = 0; i \u0026lt; board.size(); ++i) { for (int j = 0; j \u0026lt; board[0].size(); ++j) { if (root-\u0026gt;child[board[i][j] - \u0026#39;a\u0026#39;] != NULL) { search(board, visited, root, res, i, j); } } } return res; } void search(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;\u0026amp; visited, TrieNode *p, vector\u0026lt;string\u0026gt; \u0026amp;res, int i, int j) { if (!p-\u0026gt;str.empty()) { res.push_back(p-\u0026gt;str); p-\u0026gt;str.clear(); return; } if (i\u0026lt;0 || j\u0026lt;0 || i\u0026gt;board.size()-1 || j\u0026gt;board[0].size()-1) { return; } if (visited[i][j] || p-\u0026gt;child[board[i][j] - \u0026#39;a\u0026#39;] == NULL){ return; } visited[i][j] = true; search(board, visited, p-\u0026gt;child[board[i][j] - \u0026#39;a\u0026#39;], res, i + 1, j); search(board, visited, p-\u0026gt;child[board[i][j] - \u0026#39;a\u0026#39;], res, i , j+1); search(board, visited, p-\u0026gt;child[board[i][j] - \u0026#39;a\u0026#39;], res, i -1, j); search(board, visited, p-\u0026gt;child[board[i][j] - \u0026#39;a\u0026#39;], res, i , j-1); visited[i][j] = false; return; } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/array/largestrecinhistogram/",
	"title": "LargestRecInHistogram",
	"tags": [],
	"description": "",
	"content": " Given n non-negative integers representing the histogram\u0026rsquo;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\nAbove is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].\nThe largest rectangle is shown in the shaded area, which has area = 10 unit.\nExample:\nInput: [2,1,5,6,2,3] Output: 10\nSolution 1 For every bar ‘x’, we calculate the area with ‘x’ as the smallest bar in the rectangle. If we calculate such area for every bar ‘x’ and find the maximum of all areas, our task is done. How to calculate area with ‘x’ as smallest bar? We need to know index of the first smaller (smaller than ‘x’) bar on left of ‘x’ and index of first smaller bar on right of ‘x’. Let us call these indexes as ‘left index’ and ‘right index’ respectively. We traverse all bars from left to right, maintain a stack of bars. Every bar is pushed to stack once. A bar is popped from stack when a bar of smaller height is seen. When a bar is popped, we calculate the area with the popped bar as smallest bar. How do we get left and right indexes of the popped bar – the current index tells us the ‘right index’ and index of previous item in stack is the ‘left index’. Following is the complete algorithm.\n1) Create an empty stack.\n2) Start from first bar, and do following for every bar ‘heights[i]’ where ‘i’ varies from 0 to n-1. ……a) If stack is empty or heights[i] is higher than the bar at top of stack, then push ‘i’ to stack. ……b) If this bar is smaller than the top of stack, then keep removing the top of stack while top of the stack is greater. Let the removed bar be heights[tp]. Calculate area of rectangle with heights[tp] as smallest bar. For heights[tp], the ‘left index’ is previous (previous to tp) item in stack and ‘right index’ is ‘i’ (current index).\n3) If the stack is not empty, then one by one remove all bars from stack and do step 2.b for every removed bar.\nclassSolution { public: int largestRectangleArea(vector\u0026lt;int\u0026gt;\u0026amp; heights) { stack\u0026lt;int\u0026gt; st; int max_area = 0; int i = 0; while (i \u0026lt; heights.size()) { if (st.empty() || heights[st.top()] \u0026lt;= heights[i]) { st.push(i++); } else { int top = st.top(); st.pop(); int width = st.empty() ? i : i - s.top() - 1; int area = heights[top] * width; max_area = max(max_area, area); } } while (!st.empty()) { int top = st.top(); st.pop(); int width = st.empty() ? i : i - s.top() - 1; int area = heights[top] * width; max_area = max(max_area, area); } return max_area; } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/array/slidingwindowmaximum/",
	"title": "SlidingWindowMaximum",
	"tags": [],
	"description": "",
	"content": " Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note: You may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty array. Follow up: Could you solve it in linear time?  Solution 1 Using Deque to solve this question can restrict the time complexity in linear.\nThe peak element is the start of a descending sequence, so that\u0026rsquo;s what we should take a look at.\nWe store the indexes of the descending sequence to the deque, when the index of the frontiest element equals to i-k which\nmeans it\u0026rsquo;s on the verge of the window.\nWhen the current element is larger than the frontiset element, we should clear\nthe whole deque, otherise we push the index of the current element to the deque.\nThe frontiest element will be pushsed into the result vector when i\u0026gt;=k-1;\nclassSolution { public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { if (nums.empty()) { return vector\u0026lt;int\u0026gt;{}; } if (nums.size() == 1) { return vector\u0026lt;int\u0026gt;{nums[0]}; } deque\u0026lt;int\u0026gt; dq; vector\u0026lt;int\u0026gt; res; for (int i = 0; i \u0026lt; nums.size(); ++i) { if (!dq.empty() \u0026amp;\u0026amp; dq.front() == i - k) { dq.pop_front(); } while (!dq.empty() \u0026amp;\u0026amp; nums[i] \u0026gt; nums[dq.back()]) { dq.pop_back(); } dq.push_back(i); if (i \u0026gt;= k-1) { res.push_back(nums[dq.front()]); } } return res; } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/dynamicprogramming/minimumpathsum/",
	"title": "MinimumPathSum",
	"tags": [],
	"description": "",
	"content": " QuestionLink\nGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample: Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.  Solution 1 This is a simple dynamic programming problem.\nWe create a 2D array to store the current maximum path sum and return the most right-bottom value.\nclassSolution { public: int minPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(); int n = grid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n,0)); dp[0][0] = grid[0][0]; for (int i = 0; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) { dp[i][j] = grid[i][j]; continue; } else if (i == 0) { dp[i][j] = grid[i][j] + dp[i][j - 1]; } else if (j == 0) { dp[i][j] = grid[i][j] + dp[i - 1][j]; } else { dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } } return dp[m - 1][n - 1]; } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/string/decodestring/",
	"title": "DecodeString",
	"tags": [],
	"description": "",
	"content": " Given an encoded string, return it\u0026rsquo;s decoded string.\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won\u0026rsquo;t be input like 3a or 2[4].\nExamples:\ns = \u0026ldquo;3[a]2[bc]\u0026ldquo;, return \u0026ldquo;aaabcbc\u0026rdquo;. s = \u0026ldquo;3[a2[c]]\u0026ldquo;, return \u0026ldquo;accaccacc\u0026rdquo;. s = \u0026ldquo;2[abc]3[cd]ef\u0026rdquo;, return \u0026ldquo;abcabccdcdcdef\u0026rdquo;.\nSolution 1 This is a traditional recursive problem. We can use stack or recursion to solve.\nWe push parameter for calculation to stack when left bracket appears and pop to calculate while right bracket is met.\n void decode(string \u0026amp;str,int i,int times) { int start = 0; string targetString = \u0026quot;\u0026quot;; while (i \u0026lt; str.size()) { if (str[i] \u0026gt;= '0'\u0026amp;\u0026amp;str[i] \u0026lt;= '9') { string numStr=\u0026quot;\u0026quot;; while (str[i] \u0026gt;= '0'\u0026amp;\u0026amp;str[i] \u0026lt;= '9') { numStr += str[i]; i++; } times = stoi(numStr); decode(str, i, times); i = start; } else if ((str[i] \u0026gt;= 'a'\u0026amp;\u0026amp;str[i] \u0026lt;= 'z') || (str[i] \u0026gt;= 'A'\u0026amp;\u0026amp;str[i] \u0026lt;= 'Z')) { while ((str[i] \u0026gt;= 'a'\u0026amp;\u0026amp;str[i] \u0026lt;= 'z') || (str[i] \u0026gt;= 'A'\u0026amp;\u0026amp;str[i] \u0026lt;= 'Z')) { targetString += str[i]; i++; } } else if (str[i] == '[') { start = i - 1; ++i; } else if (str[i] == ']') { str.replace(start, i-start + 1, \u0026quot;\u0026quot;); string finalString = \u0026quot;\u0026quot;; for (auto index = 0; index \u0026lt; times; ++index) { finalString += targetString; } str.insert(start, finalString); return; } } } string decodeString(string s) { if (s.empty()) { return s; } int i=0; int start=0; int times=0; decode(s,i,times); return s; }  Solution 2 Re-write the stack solution to stack version.\n``` struct decodeParam { int Start = 0; int End = 0; int Times = 0; string TargetString = \u0026ldquo;\u0026rdquo;; }; string decodeString(string str) {\nif (str.empty()) { return str; } stack\u0026lt;decodeParam*\u0026gt; parseStack; int i = 0; while (i \u0026lt; str.size()) { if (str[i] \u0026gt;= '0'\u0026amp;\u0026amp;str[i] \u0026lt;= '9') { decodeParam* param = new decodeParam(); if (!parseStack.empty()) { if (parseStack.top()-\u0026gt;Start == i) { while (str[i] \u0026gt;= '0'\u0026amp;\u0026amp;str[i] \u0026lt;= '9') { ++i; } continue; } } param-\u0026gt;Start = i; string numStr = \u0026quot;\u0026quot;; while (str[i] \u0026gt;= '0'\u0026amp;\u0026amp;str[i] \u0026lt;= '9') { numStr += str[i]; ++i; } param-\u0026gt;Times = stoi(numStr); parseStack.push(param); } else if ((str[i] \u0026gt;= 'a'\u0026amp;\u0026amp;str[i] \u0026lt;= 'z') || (str[i] \u0026gt;= 'A'\u0026amp;\u0026amp;str[i] \u0026lt;= 'Z')) { if (parseStack.empty()) { i++; continue; } string targetStr = \u0026quot;\u0026quot;; while ((str[i] \u0026gt;= 'a'\u0026amp;\u0026amp;str[i] \u0026lt;= 'z') || (str[i] \u0026gt;= 'A'\u0026amp;\u0026amp;str[i] \u0026lt;= 'Z')) { targetStr += str[i]; ++i; } decodeParam* param = parseStack.top(); param-\u0026gt;TargetString = targetStr; } else if (str[i] == '[') { ++i; } else if (str[i] == ']') { decodeParam* param = parseStack.top(); param-\u0026gt;End = i; str.replace(param-\u0026gt;Start, param-\u0026gt;End-param-\u0026gt;Start+1, \u0026quot;\u0026quot;); int times = param-\u0026gt;Times; string finalString = \u0026quot;\u0026quot;; for (auto index = 0; index \u0026lt; times; ++index) { finalString += param-\u0026gt;TargetString; } str.insert(param-\u0026gt;Start, finalString); parseStack.pop(); if (!parseStack.empty()) { i = parseStack.top()-\u0026gt;Start; } else { i = param-\u0026gt;Start + finalString.size(); } } } return str; } ```  "
},
{
	"uri": "http://falcontw.me/codingquestions/array/numberofislands/",
	"title": "NumberOfIslands",
	"tags": [],
	"description": "",
	"content": "Questions Link\nGiven a 2d grid map of \u0026lsquo;1\u0026rsquo;s (land) and \u0026lsquo;0\u0026rsquo;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nExample 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3  BFS will do. Just like the word search\nclassSolution { public: int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int islandCount=0; for(int i =0;i\u0026lt;grid.size();++i) for(int j=0;j\u0026lt;grid[i].size();++j) { if(grid[i][j]==\u0026#39;1\u0026#39;) { bfsIsland(grid,i,j); ++islandCount; } } return islandCount; } void bfsIsland(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;grid, int i, int j) { if(i\u0026lt;0||j\u0026lt;0||i\u0026gt;grid.size()-1||j\u0026gt;grid[i].size()-1) { return; } if(grid[i][j]==\u0026#39;0\u0026#39;||grid[i][j]==\u0026#39;#\u0026#39;) { return; } if(grid[i][j]==\u0026#39;1\u0026#39;) { grid[i][j]=\u0026#39;#\u0026#39;; } bfsIsland(grid,i+1,j); bfsIsland(grid,i-1,j); bfsIsland(grid,i,j+1); bfsIsland(grid,i,j-1); } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/array/maxareaofislands/",
	"title": "MaxAreaOfIslands",
	"tags": [],
	"description": "",
	"content": " Question Link\nGiven a non-empty 2D array grid of 0\u0026rsquo;s and 1\u0026rsquo;s, an island is a group of 1\u0026rsquo;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nFind the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)\nExample 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally. Example 2: [[0,0,0,0,0,0,0,0]] Given the above grid, return 0. Note: The length of each dimension in the given grid does not exceed 50.  Solution 1 DFS will work. This is a simpler problem of Word Search\nint maxAreaOfIsland(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int maxVal =0; for(int i=0;i\u0026lt;grid.size();++i) for(int j=0;j\u0026lt;grid[i].size();++j) { if(grid[i][j]==1) { maxVal = max(maxVal,areaOfIsland(grid,i,j)); } } return maxVal; } int areaOfIsland(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, int i, int j) { if(i\u0026gt;=0\u0026amp;\u0026amp;i\u0026lt;grid.size() \u0026amp;\u0026amp; j\u0026gt;=0 \u0026amp;\u0026amp;j\u0026lt;grid[i].size() \u0026amp;\u0026amp; grid[i][j]==1) { grid[i][j]=0; return 1+areaOfIsland(grid,i+1,j)+areaOfIsland(grid,i-1,j) +areaOfIsland(grid,i,j+1)+areaOfIsland(grid,i,j-1); } return 0; } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/search_2d_matrix_2/",
	"title": "Search_2D_Matrix_2",
	"tags": [],
	"description": "",
	"content": " Question Link\nWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\nIntegers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.\nExample: Consider the following matrix: [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] Given target = 5, return true. Given target = 20, return false.  Solution1 The matrix is ascending from left to right, from top to bottom.\nSo we can start from the upper right element to shrink the search space.\nbool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int x = 0; int y = matrix[0].size() - 1; int row = matrix.size(); int col = matrix[0].size(); while (x \u0026lt; row \u0026amp;\u0026amp; y \u0026gt; 0) { if (matrix[x][y] == target) { return true; } else if (matrix[x][y] \u0026gt; target) { y--; } else { x++; } } return false; } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/search_2d_matrix_1/",
	"title": "Search_2D_Matrix_1",
	"tags": [],
	"description": "",
	"content": " Question Link\nWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\nIntegers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.\nExample 1: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true Example 2: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 Output: false  Solution 1 Binary search will do the job.\nbool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); if (target\u0026lt;matrix[0][0] || target \u0026gt; matrix.back().back()) { return false; } int start = 0; int end = m * n - 1; while (start \u0026lt;= end) { int mid = (start + end) / 2; int value = matrix[mid / n][mid%n]; if (value == target) { return true; } else if (value \u0026lt; target) { start = mid + 1; } else { end = mid - 1; } } return false; } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/3sum/",
	"title": "3Sum",
	"tags": [],
	"description": "",
	"content": " Question Link\nGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\nNote:\nThe solution set must not contain duplicate triplets.\nSolution 1 Using pair and hashtable with the same strategy in TwoSum can solve this question too.\nHowever, it will lead to time limit excession in some large cases.\nclassSolution { private: void _parseResult(int leadNumber, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; input) { unordered_set\u0026lt;vector\u0026lt;int\u0026gt;, myVectorHash\u0026gt; result; for (int i = 0; i \u0026lt; input.size(); ++i) { for (auto iterator = input.begin(); iterator != input.end(); ++iterator) { vector\u0026lt;int\u0026gt; output = { leadNumber,iterator-\u0026gt;first,iterator-\u0026gt;second }; result.insert(output); } } for (auto i = result.begin(); i != result.end(); ++i) { totalResult.push_back(*i); } } public: struct myVectorHash { size_t operator()(vector\u0026lt;int\u0026gt;_val)const { return static_cast\u0026lt;size_t\u0026gt;(_val.size() + _val.back() - _val.front()); } }; struct myPairHash { size_t operator()(pair\u0026lt;int, int\u0026gt;_val)const { return static_cast\u0026lt;size_t\u0026gt;((_val.first+10) * 2 + _val.second); } }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; totalResult; const bool isExist = true; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp;nums) { sort(nums.begin(), nums.end()); threeSumHelper(nums); return totalResult; } void threeSumHelper(vector\u0026lt;int\u0026gt;\u0026amp;nums) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairResult; for (int i = 0; i \u0026lt; nums.size(); ++i) { if (i\u0026gt;0 \u0026amp;\u0026amp; nums[i]==nums[i-1]) { continue; } int leadNumber = nums[i]; int target = leadNumber*-1; vector\u0026lt;int\u0026gt; targetVec = vector\u0026lt;int\u0026gt;(nums.begin() + i+1, nums.end()); pairResult = twoSum(targetVec, target); if (!pairResult.empty()) { _parseResult(leadNumber, pairResult); } } } vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_set \u0026lt;pair\u0026lt;int, int\u0026gt;, myPairHash\u0026gt; result; unordered_map\u0026lt;int, int\u0026gt; map; for (int i = 0; i \u0026lt; nums.size(); ++i) { auto iterator = map.find(target - nums[i]); if (iterator == map.end()) { map[nums[i]] = i; } else { result.insert(make_pair(nums[iterator-\u0026gt;second],nums[i])); } } return vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;(result.begin(), result.end()); } };  Solution 2 We sort the array first to keep it in ascending order.\nThen we take every element from the start and find the other two from the next element.\nHere we use dubble pointer to squeeze out the answers, since the whole array is in ascending order.\nWe can avoid doing some dupicate operations.\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(), nums.end()); if (nums.size() \u0026lt; 3) { return result; } for (int i = 0; i \u0026lt; nums.size()-2; ++i) { if(nums[i]\u0026gt;0) { break; } if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1])continue; int start = i + 1; int end = nums.size()-1; while (start \u0026lt; end) { int target = nums[i] * -1; int curSum = nums[start] + nums[end]; if (target == curSum) { vector\u0026lt;int\u0026gt; res; res.push_back(nums[i]); res.push_back(nums[start]); res.push_back(nums[end]); result.push_back(res); ++start; --end; while (nums[start] == nums[start - 1])++start; while (nums[end] == nums[end + 1])--end; } else if (target \u0026gt; curSum) { ++start; while (nums[start] == nums[start - 1])++start; } else { --end; while (nums[end] == nums[end + 1])--end; } } } return result; } "
},
{
	"uri": "http://falcontw.me/codingquestions/string/longestpalindromicsubstring/",
	"title": "LongestPalindromicSubstring",
	"tags": [],
	"description": "",
	"content": " Question Link\nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\nExample 1: Input: \u0026quot;babad\u0026quot; Output: \u0026quot;bab\u0026quot; Note: \u0026quot;aba\u0026quot; is also a valid answer. Example 2: Input: \u0026quot;cbbd\u0026quot; Output: \u0026quot;bb\u0026quot;  Solution1 This is a classic dynamic programming problem.\nWe must figure out what Subproblem and Optimal structure.\nThe optimal solution can derived from every Optimal solution of the subproblems.\nHere we can easily figure out that the Longest palindromic string is related to all the short palindromic string,\nLet P[i,j] = is section [i,j] is a palindrome.\nFor example : S= a b c c b Index = 0 1 2 3 4\nWe can see that\nP[0,0] =1 //each char is a palindrome P[0,1] =S[0] == S[1] , P[1,1] =1 P[0,2] = S[0] == S[2] \u0026amp;\u0026amp; P[1,1], P[1,2] = S[1] == S[2] , P[2,2] = 1 P[0,3] = S[0] == S[3] \u0026amp;\u0026amp; P[1,2], P[1,3] = S[1] == S[3] \u0026amp;\u0026amp; P[2,2] , P[2,3] =S[2] ==S[3], P[3,3]=1\nHere we can conclude these examples to rules.\nP[i,j] = 1 if i ==j = S[i] ==S[j] if j = i+1 = S[i] == S[j] \u0026amp;\u0026amp; P[i+1][j-1] if j\u0026gt;i+1\nstring longestPalindrome(string s) { if (s.size() \u0026lt;= 1) { return s; } int start = 0; int end = 0; int currentMaxLen = 0; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(s.size(), vector\u0026lt;bool\u0026gt;(s.size(), false)); for (int i = 0; i \u0026lt; s.size(); ++i) { for (int j = 0; j \u0026lt; i; ++j) { dp[j][i] = s[i] == s[j] \u0026amp;\u0026amp; (i - j \u0026lt;= 2 || dp[j + 1][i - 1]); if (dp[j][i]) { if (currentMaxLen\u0026lt;i - j + 1) { start = j; end = i; currentMaxLen = i - j + 1; } } } dp[i][i] = true; } return s.substr(start, end-start+1); // Should not replace end-start+1 with currentMaxLen since in case \u0026#34;ac\u0026#34;,currentMaxLen will be zero but still we need one char as answer  } "
},
{
	"uri": "http://falcontw.me/codingquestions/tree/kthsmallestelementinbst/",
	"title": "KthSmallestElementInBST",
	"tags": [],
	"description": "",
	"content": "Questions Link\nGiven a binary search tree, write a function kthSmallest to find the kth smallest element in it.\nNote: You may assume k is always valid, 1 ≤ k ≤ BST\u0026rsquo;s total elements.\nExample 1: Input: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 Output: 3  Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\n##Solution 1\nInorder traverse will do. Pass the k value to each recursive call and return when the\nint kthSmallest(TreeNode* root, int k) { int ans = 0; if (root == NULL) { return 0; } helper(root, k, ans); return ans; } void helper(TreeNode* root, int \u0026amp;k,int \u0026amp;ans) { if (root-\u0026gt;left != NULL) { helper(root-\u0026gt;left, k,ans); } if (k == 0) { ans = root-\u0026gt;val; } k = k - 1; if (root-\u0026gt;right != NULL) { helper(root-\u0026gt;right, k, ans); } }  ##Solution 2 In the followup part, if the BST is modified often, the cost of traversing will be expensive.\nSince the kth smallest element has k-1 nodes in its left-hand side,we may use Divide and Conquer to squeeze out the value.\nint kthSmallest(TreeNode* root, int k) { int count = countNodes(root-\u0026gt;left); if (count == k - 1) { return root-\u0026gt;val; } else if (count \u0026lt; k - 1) { return kthSmallest(root-\u0026gt;right,k-count-1 ); } else { return kthSmallest(root-\u0026gt;left, k); } } int countNodes(TreeNode* root) { if (root == NULL) { return 0; } return 1 + countNodes(root-\u0026gt;left) + countNodes(root-\u0026gt;right); } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/wordsearch/",
	"title": "WordSearch",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \u0026quot;ABCCED\u0026quot;, return true. Given word = \u0026quot;SEE\u0026quot;, return true. Given word = \u0026quot;ABCB\u0026quot;, return false.  Solution 1 We need to start from everypoint and search in four directions to check if there is word matched, in this way,\nwe apply DFS and backtracking to this problem, and initialize a \u0026lsquo;visited\u0026rsquo; array to keep recording where this entry is visited\nfor traversing the whole board.\nbool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { if (board.empty() || board[0].empty()) { return false; } vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(board.size(), vector\u0026lt;bool\u0026gt;(board[0].size(), false)); for (int i = 0; i\u0026lt;board.size(); ++i) { for (int j = 0; j\u0026lt;board[0].size(); ++j) { if (searchWord(board,word,0,i, j, visited)) { return true; } } } return false; } bool searchWord(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board,string word,int idx,int i, int j, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; \u0026amp;visited) { if (idx == word.size()) { return true; } if (i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt; board.size() - 1 || j \u0026gt; board[0].size() - 1 || visited[i][j] || board[i][j] != word[idx]) { return false; } visited[i][j] = true; bool res = searchWord(board, word, idx + 1, i - 1, j, visited) || searchWord(board, word, idx + 1, i + 1, j, visited) || searchWord(board, word, idx + 1, i, j - 1, visited) || searchWord(board, word, idx + 1, i, j + 1, visited); visited[i][j] = false; return res; }  Solution 2 Or otherwise , we may just modify the visited board entry and restore it afterwards, then we don\u0026rsquo;t need additional visited array.\nbool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { if (board.empty() || board[0].empty()) { return false; } vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(board.size(), vector\u0026lt;bool\u0026gt;(board[0].size(), false)); for (int i = 0; i\u0026lt;board.size(); ++i) { for (int j = 0; j\u0026lt;board[0].size(); ++j) { if (searchWord(board,word,0,i, j, visited)) { return true; } } } return false; } bool searchWord(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board,string word,int idx,int i, int j, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; \u0026amp;visited) { if (idx == word.size()) { return true; } if (i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt; board.size() - 1 || j \u0026gt; board[0].size() - 1 || board[i][j] != word[idx]) { return false; } char c = board[i][j]; board[i][j] = \u0026#39;#\u0026#39;; bool res = searchWord(board, word, idx + 1, i - 1, j, visited) || searchWord(board, word, idx + 1, i + 1, j, visited) || searchWord(board, word, idx + 1, i, j - 1, visited) || searchWord(board, word, idx + 1, i, j + 1, visited); board[i][j] = c; return res; } "
},
{
	"uri": "http://falcontw.me/codingquestions/systemdesign/lru_cache/",
	"title": "LRU Cache",
	"tags": [],
	"description": "",
	"content": " Questions Link\nDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\nput(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity,\nit should invalidate the least recently used item before inserting a new item.\nFollow up: Could you do both operations in O(1) time complexity?\nExample:\nLRUCache cache = new LRUCache( 2 /* capacity */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4  Solution Using hashtable -\u0026gt; TLE Using input key as the key of the map and the value is composed of the value and a time stamp.\nThe least being used is the value, the smaller is the time stamp.\nget(int key) : Set time of target entry to 0, and the time of the rest entries are deducted by one.  put(int key) : If capacity is not yet full,insert the key and value, set time to zero, or delete the entry with the smallest time and insert the new one.  Time complexity is O(1) when getting value but deducting time is time wasting that leads to TLE.\nUsing Linkedlist -\u0026gt;TLE Search for target entry is time wasting, not O(1).\nUsing DoublyLinkedlist + Hashtable Double-linked list along with Hashtable can ensure all the operations are O(1) complexity;\nWhen we are trying to get the value, we visit the map, if there is need to modify the doubly linkedlist,\nwe don\u0026rsquo;t need to search from the very beginning.\nstruct LRUElement { int key; int value; LRUElement* prev; LRUElement* next; LRUElement() :key(0), value(0), prev(NULL), next(NULL) {}; }; classLRUCache { private: int _capacity; int _count; LRUElement* head; LRUElement* tail; unordered_map\u0026lt;int, LRUElement*\u0026gt; map; void _DetachNode(LRUElement* node) { node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; } void _MoveToFront(LRUElement* node) { node-\u0026gt;next = head-\u0026gt;next; node-\u0026gt;prev = head; head-\u0026gt;next = node; node-\u0026gt;next-\u0026gt;prev = node; } void _RemoveTailNode() { LRUElement* node = tail-\u0026gt;prev; _DetachNode(node); map.erase(node-\u0026gt;key); --_count; } public: LRUCache(int capacity) { _capacity = capacity; _count = 0; head = new LRUElement(); tail = new LRUElement(); head-\u0026gt;prev = NULL; head-\u0026gt;next = tail; tail-\u0026gt;prev = head; tail-\u0026gt;next = NULL; } int get(int key) { if (map.find(key) == map.end()) { return -1; } else { LRUElement* node = map[key]; _DetachNode(node); _MoveToFront(node); return node-\u0026gt;value; } } void put(int key, int value) { if (map.find(key)==map.end()) { LRUElement* node = new LRUElement(); if (_count == _capacity) { _RemoveTailNode(); } node -\u0026gt; key = key; node-\u0026gt;value = value; map[key] = node; _MoveToFront(node); ++_count; } else { LRUElement* node = map[key]; _DetachNode(node); node-\u0026gt;value = value; _MoveToFront(node); } } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/tree/binarytreelevelorder/",
	"title": "BinaryTreeLevelOrder",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven a binary tree, return the level order traversal of its nodes\u0026rsquo; values. (ie, from left to right, level by level).\nFor example: Given binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ]  Solution 1 BFS is the one of the most common ways to solve this questions.\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; totalResult; if (root == NULL) { return totalResult; } queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); while (!q.empty()) { int size = q.size(); vector\u0026lt;int\u0026gt; res; for (int i = 0; i \u0026lt; size; ++i) { TreeNode* node = q.front(); res.push_back(node-\u0026gt;val); q.pop(); if (node-\u0026gt;left) { q.push(node-\u0026gt;left); } if (node-\u0026gt;right) { q.push(node-\u0026gt;right); } } totalResult.push_back(res); } return totalResult; } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/sortcolors/",
	"title": "SortColors",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\nNote: You are not suppose to use the library\u0026rsquo;s sort function for this problem.\nExample: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up:  A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0\u0026rsquo;s, 1\u0026rsquo;s, and 2\u0026rsquo;s, then overwrite array with total number of 0\u0026rsquo;s, then 1\u0026rsquo;s and followed by 2\u0026rsquo;s. Could you come up with a one-pass algorithm using only constant space?\nSolution 1 The two pass method is simple. We may just try to record the times each number appears.\nAnd restore the numbers back to the result.\nclassSolution { public: void sortColors(int A[], int n) { int count[3] = {0}, idx = 0; for (int i = 0; i \u0026lt; n; ++i) ++count[A[i]]; for (int i = 0; i \u0026lt; 3; ++i) { for (int j = 0; j \u0026lt; count[i]; ++j) { A[idx++] = i; } } } };  Solution 2 Since the order is not strictly ascending,so we don\u0026rsquo;t really need to sort the whole array,\nwhat we need to come to in mind is the method in Quick sort which helps to partition the array\naccording to the chosen pivot.\nvoid sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int left =0; int right =nums.size()-1; int pivot=0; while(left\u0026lt;=right) { if(nums[left]==2) { swap(nums[left],nums[right--]); } else if(nums[left]==0) { swap(nums[left++],nums[pivot++]); } else { left++; } } } "
},
{
	"uri": "http://falcontw.me/codingquestions/tree/validatebst/",
	"title": "ValidateBST",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.  Example 1: Input: 2 / \\ 1 3 Output: true  To validate a Binary Search Tree, we can either utilize its property to validate\nor we can have inorder traverse to see if the previous element is smaller than current one,\nif not, that implies this BST is invalid.\nSolution 1 We validate each node of the tree to see if it meets with the property.\nclassSolution { public: bool isValidBST(TreeNode* root) { return checkValidBST(root,LONG_MIN,LONG_MAX); } bool checkValidBST(TreeNode* root,long min,long max) { if(root==NULL) { return true; } if(root-\u0026gt;val \u0026lt;= min || root-\u0026gt;val \u0026gt;=max) { return false; } return checkValidBST(root-\u0026gt;left,min,root-\u0026gt;val) \u0026amp;\u0026amp; checkValidBST(root-\u0026gt;right,root-\u0026gt;val,max); } };  Solution 2 We traverse the whole tree with inorder and see if the prev element is always smaller than current one.\nclassSolution { public: bool isValidBST(TreeNode* root) { long prev = LONG_MIN; return inorderTraverse(root,prev); } bool inorderTraverse(TreeNode* root, long\u0026amp; prev) { if(root==NULL) { return true; } if(!inorderTraverse(root-\u0026gt;left,prev)) { return false; } if(prev \u0026gt;=root-\u0026gt;val) { return false; } prev = root-\u0026gt;val; if(!inorderTraverse(root-\u0026gt;right,prev)) { return false; } return true; } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/array/wigglesort2/",
	"title": "WiggleSort II",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven an unsorted array nums, reorder it such that nums[0] \u0026lt; nums[1] \u0026gt; nums[2] \u0026lt; nums[3]\u0026hellip;.\nExample 1: Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. Example 2: Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2].  Solution Sol A:\nTo make the array wiggle like, Stefan Pochmann \u0026rsquo;s post\nintroduced a way called virtual indexing to reorder the map position and the index itself.\nConsider\nA(i) = nums[(2*i+1)/(n|1)]  This helps us to recorder the element and mapping with wiggle order.\n A(0) – \u0026gt; nums[1] A(1) – \u0026gt; nums[3] A(2) – \u0026gt; nums[5] A(3) – \u0026gt; nums[7] A(4) – \u0026gt; nums[9] A(5) – \u0026gt; nums[0] A(6) – \u0026gt; nums[2] A(7) – \u0026gt; nums[4] A(8) – \u0026gt; nums[6] A(9) – \u0026gt; nums[8]  Our target is to make the 1,3,5,7,\u0026hellip; elements always bigger than the 0,2,4,6,8 elements.\nThen let\u0026rsquo;s focus on the A(i) array, in the new A(i) array, we need to place the ones bigger than the median starting from the front\nand place the ones smaller than the median from the last position. In this way, we can ensure the odd-indexed elemnt is always larger\nthan the even-indexed element. To acheive this, we can refer to the Sort color; problem\nclassSolution { public: int newIndex(int index, int n) { return (1 + 2 * index) % (n | 1); } void wiggleSort(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int size = nums.size(); int front = 0; int mid = (size+1) / 2; int pos = 0; nth_element(nums.begin(), nums.begin() + mid, nums.end()); // Quick select to partition the array base on given pivot  int left = 0, i = 0, right = size - 1; int median = nums[mid]; while (i \u0026lt;= right) // Sort color  { if (nums[newIndex(i,size)] \u0026gt; median) { swap(nums[newIndex(left++,size)], nums[newIndex(i++,size)]); } else if (nums[newIndex(i,size)] \u0026lt; median) { swap(nums[newIndex(right--,size)], nums[newIndex(i,size)]); } else { i++; } } } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/array/median_of_two_sorted_array_with_different_size/",
	"title": "Median of 2 sorted array",
	"tags": [],
	"description": "",
	"content": " Questions Link\nExample 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty.  Solution This is indeed an kth smalleset element questions. The kth value turns to be median in this case.\nSince we need to implement this within logarithmic time. We need to take advantage of Binary Search.\nThe point is that it\u0026rsquo;s not what is left but what we delete matters.\nSuppose there is two array called A and B.\nA: 1,3,5,6,10.\nB: 2,6,9,13\nand we wanna find the 7th element.\n7\u0026frasl;2 =3, So we take out the 3th element from A and B.\nA[2] = 5, B[2] =9\nHere we can see that B[2]\u0026gt;A[2] which means the 7th elements won\u0026rsquo;t be in the top 3 elements of A.\nThen we can remove the top 3 elemets of A and the problem is reduced to finding K = 7-K/2 = 4;\nA: 6,10\nB: 2,6,9,13\nK/2 = 2 =\u0026gt; A[1] = 10, B[2] = 9;\nA[1] \u0026gt; B[1]; Remove the top elements of B\nK= 4-2=2\nK/2 = 1\nA: 6,10 B: 9,13 A[0] = 6, B[0]=9\nB[0]\u0026gt;A[0] So we remove A[0]\nA: 10 B: 9,13 K = 2-1 = 1\nNow we can return the smallest one as the answer.\nNote that there will possily be Corner cases\n1.one array is empty, return the kth number of the nonempty array.  2.even number of total elements,we need to find two middle numbers and calculate the median.  3.k may be larger than the length of the smaller array.\ndouble findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int total = nums1.size() + nums2.size(); if (total % 2 != 0) { return findKth(nums1, nums2, total / 2 + 1); } else { return (findKth(nums1, nums2, total / 2) + findKth(nums1, nums2, total / 2 + 1)) *0.5; } } int findKth(vector\u0026lt;int\u0026gt; nums1, vector\u0026lt;int\u0026gt; nums2, int k) { int m = nums1.size(); int n = nums2.size(); if (m \u0026gt; n) return findKth(nums2, nums1, k); if (m == 0) return nums2[k - 1]; if (k == 1) return min(nums1[0], nums2[0]); int i = min(m, k / 2), j = min(n, k / 2); if (nums1[i - 1] \u0026gt; nums2[j - 1]) { return findKth(nums1, vector\u0026lt;int\u0026gt;(nums2.begin() + j, nums2.end()), k - j); } else { return findKth(vector\u0026lt;int\u0026gt;(nums1.begin() + i, nums1.end()), nums2, k - i); } return 0; } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/",
	"title": "Array",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/codingquestions/dynamicprogramming/",
	"title": "DynamicProgrammings",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/",
	"title": "Hanswu",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/codingquestions/string/",
	"title": "Strings",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/codingquestions/systemdesign/",
	"title": "SystemDesigns",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/codingquestions/tree/",
	"title": "Trees",
	"tags": [],
	"description": "",
	"content": ""
}]