[
{
	"uri": "http://falcontw.me/learninghistory/",
	"title": "Learning History",
	"tags": [],
	"description": "",
	"content": " \nNot limited to Computer science. "
},
{
	"uri": "http://falcontw.me/codingquestions/",
	"title": "Coding Questions",
	"tags": [],
	"description": "",
	"content": " \nLeetcode / Hackerrank. "
},
{
	"uri": "http://falcontw.me/codingquestions/array/wordsearch/",
	"title": "WordSearch",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \u0026quot;ABCCED\u0026quot;, return true. Given word = \u0026quot;SEE\u0026quot;, return true. Given word = \u0026quot;ABCB\u0026quot;, return false.  Solution 1 We need to start from everypoint and search in four directions to check if there is word matched, in this way,\nwe apply DFS and backtracking to this problem, and initialize a \u0026lsquo;visited\u0026rsquo; array to keep recording where this entry is visited\nfor traversing the whole board.\nbool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { if (board.empty() || board[0].empty()) { return false; } vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(board.size(), vector\u0026lt;bool\u0026gt;(board[0].size(), false)); for (int i = 0; i\u0026lt;board.size(); ++i) { for (int j = 0; j\u0026lt;board[0].size(); ++j) { if (searchWord(board,word,0,i, j, visited)) { return true; } } } return false; } bool searchWord(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board,string word,int idx,int i, int j, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; \u0026amp;visited) { if (idx == word.size()) { return true; } if (i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt; board.size() - 1 || j \u0026gt; board[0].size() - 1 || visited[i][j] || board[i][j] != word[idx]) { return false; } visited[i][j] = true; bool res = searchWord(board, word, idx + 1, i - 1, j, visited) || searchWord(board, word, idx + 1, i + 1, j, visited) || searchWord(board, word, idx + 1, i, j - 1, visited) || searchWord(board, word, idx + 1, i, j + 1, visited); visited[i][j] = false; return res; } "
},
{
	"uri": "http://falcontw.me/codingquestions/systemdesign/lru_cache/",
	"title": "LRU Cache",
	"tags": [],
	"description": "",
	"content": " Questions Link\nDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\nput(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity,\nit should invalidate the least recently used item before inserting a new item.\nFollow up: Could you do both operations in O(1) time complexity?\nExample:\nLRUCache cache = new LRUCache( 2 /* capacity */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4  Solution Using hashtable -\u0026gt; TLE Using input key as the key of the map and the value is composed of the value and a time stamp.\nThe least being used is the value, the smaller is the time stamp.\nget(int key) : Set time of target entry to 0, and the time of the rest entries are deducted by one.  put(int key) : If capacity is not yet full,insert the key and value, set time to zero, or delete the entry with the smallest time and insert the new one.  Time complexity is O(1) when getting value but deducting time is time wasting that leads to TLE.\nUsing Linkedlist -\u0026gt;TLE Search for target entry is time wasting, not O(1).\nUsing DoublyLinkedlist + Hashtable Double-linked list along with Hashtable can ensure all the operations are O(1) complexity;\nWhen we are trying to get the value, we visit the map, if there is need to modify the doubly linkedlist,\nwe don\u0026rsquo;t need to search from the very beginning.\nstruct LRUElement { int key; int value; LRUElement* prev; LRUElement* next; LRUElement() :key(0), value(0), prev(NULL), next(NULL) {}; }; classLRUCache { private: int _capacity; int _count; LRUElement* head; LRUElement* tail; unordered_map\u0026lt;int, LRUElement*\u0026gt; map; void _DetachNode(LRUElement* node) { node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; } void _MoveToFront(LRUElement* node) { node-\u0026gt;next = head-\u0026gt;next; node-\u0026gt;prev = head; head-\u0026gt;next = node; node-\u0026gt;next-\u0026gt;prev = node; } void _RemoveTailNode() { LRUElement* node = tail-\u0026gt;prev; _DetachNode(node); map.erase(node-\u0026gt;key); --_count; } public: LRUCache(int capacity) { _capacity = capacity; _count = 0; head = new LRUElement(); tail = new LRUElement(); head-\u0026gt;prev = NULL; head-\u0026gt;next = tail; tail-\u0026gt;prev = head; tail-\u0026gt;next = NULL; } int get(int key) { if (map.find(key) == map.end()) { return -1; } else { LRUElement* node = map[key]; _DetachNode(node); _MoveToFront(node); return node-\u0026gt;value; } } void put(int key, int value) { if (map.find(key)==map.end()) { LRUElement* node = new LRUElement(); if (_count == _capacity) { _RemoveTailNode(); } node -\u0026gt; key = key; node-\u0026gt;value = value; map[key] = node; _MoveToFront(node); ++_count; } else { LRUElement* node = map[key]; _DetachNode(node); node-\u0026gt;value = value; _MoveToFront(node); } } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/tree/binarytreelevelorder/",
	"title": "BinaryTreeLevelOrder",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven a binary tree, return the level order traversal of its nodes\u0026rsquo; values. (ie, from left to right, level by level).\nFor example: Given binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ]  Solution 1 BFS is the one of the most common ways to solve this questions.\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; totalResult; if (root == NULL) { return totalResult; } queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); while (!q.empty()) { int size = q.size(); vector\u0026lt;int\u0026gt; res; for (int i = 0; i \u0026lt; size; ++i) { TreeNode* node = q.front(); res.push_back(node-\u0026gt;val); q.pop(); if (node-\u0026gt;left) { q.push(node-\u0026gt;left); } if (node-\u0026gt;right) { q.push(node-\u0026gt;right); } } totalResult.push_back(res); } return totalResult; } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/sortcolors/",
	"title": "SortColors",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\nNote: You are not suppose to use the library\u0026rsquo;s sort function for this problem.\nExample: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up:  A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0\u0026rsquo;s, 1\u0026rsquo;s, and 2\u0026rsquo;s, then overwrite array with total number of 0\u0026rsquo;s, then 1\u0026rsquo;s and followed by 2\u0026rsquo;s. Could you come up with a one-pass algorithm using only constant space?\nSolution 1 The two pass method is simple. We may just try to record the times each number appears.\nAnd restore the numbers back to the result.\nclassSolution { public: void sortColors(int A[], int n) { int count[3] = {0}, idx = 0; for (int i = 0; i \u0026lt; n; ++i) ++count[A[i]]; for (int i = 0; i \u0026lt; 3; ++i) { for (int j = 0; j \u0026lt; count[i]; ++j) { A[idx++] = i; } } } };  Solution 2 Since the order is not strictly ascending,so we don\u0026rsquo;t really need to sort the whole array,\nwhat we need to come to in mind is the method in Quick sort which helps to partition the array\naccording to the chosen pivot.\nvoid sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int left =0; int right =nums.size()-1; int pivot=0; while(left\u0026lt;=right) { if(nums[left]==2) { swap(nums[left],nums[right--]); } else if(nums[left]==0) { swap(nums[left++],nums[pivot++]); } else { left++; } } } "
},
{
	"uri": "http://falcontw.me/codingquestions/tree/validatebst/",
	"title": "ValidateBST",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.  Example 1: Input: 2 / \\ 1 3 Output: true  To validate a Binary Search Tree, we can either utilize its property to validate\nor we can have inorder traverse to see if the previous element is smaller than current one,\nif not, that implies this BST is invalid.\nSolution 1 We validate each node of the tree to see if it meets with the property.\nclassSolution { public: bool isValidBST(TreeNode* root) { return checkValidBST(root,LONG_MIN,LONG_MAX); } bool checkValidBST(TreeNode* root,long min,long max) { if(root==NULL) { return true; } if(root-\u0026gt;val \u0026lt;= min || root-\u0026gt;val \u0026gt;=max) { return false; } return checkValidBST(root-\u0026gt;left,min,root-\u0026gt;val) \u0026amp;\u0026amp; checkValidBST(root-\u0026gt;right,root-\u0026gt;val,max); } };  Solution 2 We traverse the whole tree with inorder and see if the prev element is always smaller than current one.\nclassSolution { public: bool isValidBST(TreeNode* root) { long prev = LONG_MIN; return inorderTraverse(root,prev); } bool inorderTraverse(TreeNode* root, long\u0026amp; prev) { if(root==NULL) { return true; } if(!inorderTraverse(root-\u0026gt;left,prev)) { return false; } if(prev \u0026gt;=root-\u0026gt;val) { return false; } prev = root-\u0026gt;val; if(!inorderTraverse(root-\u0026gt;right,prev)) { return false; } return true; } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/array/wigglesort2/",
	"title": "WiggleSort II",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven an unsorted array nums, reorder it such that nums[0] \u0026lt; nums[1] \u0026gt; nums[2] \u0026lt; nums[3]\u0026hellip;.\nExample 1: Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. Example 2: Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2].  Solution Sol A:\nWe can simply sort this array and reorganize the array.\nAfter we sort the array, the array will be partitioned as the smaller part mid and the larger part.\nWe pick the last element from the smaller part as the 1st element, then we pick another last element from the larger part as the 2nd element.\nThis\n"
},
{
	"uri": "http://falcontw.me/learninghistory/softwareengineering/solidprinciple/",
	"title": "SOLID Principle",
	"tags": [],
	"description": "",
	"content": " What is SOLID principle ? SOLID stands for five basic principles of object-oriented programming and design. The intention is that these principles, when applied together, will make it more likely that a programmer will create a system that is easy to maintain and extend over time.The principles of SOLID are guidelines that can be applied while working on software to remove code smells by providing a framework through which the programmer may refactor the software\u0026rsquo;s source code until it is both legible and extensible.\nSOLID stands for： Single-responsibility principle Open-closed principle Liskov substitution principle Interface segregation principle Dependency inversion principle\n[SINGLE-RESPONSIBILITY PRINCIPLE] Definition: A class should have only one reason to change.\n"
},
{
	"uri": "http://falcontw.me/learninghistory/softwareengineering/",
	"title": "Software Engineering",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/codingquestions/array/median_of_two_sorted_array_with_different_size/",
	"title": "Median of 2 sorted array",
	"tags": [],
	"description": "",
	"content": " Questions Link\nExample 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty.  Solution This is indeed an kth smalleset element questions. The kth value turns to be median in this case.\nSince we need to implement this within logarithmic time. We need to take advantage of Binary Search.\nThe point is that it\u0026rsquo;s not what is left but what we delete matters.\nSuppose there is two array called A and B.\nA: 1,3,5,6,10.\nB: 2,6,9,13\nand we wanna find the 7th element.\n7\u0026frasl;2 =3, So we take out the 3th element from A and B.\nA[2] = 5, B[2] =9\nHere we can see that B[2]\u0026gt;A[2] which means the 7th elements won\u0026rsquo;t be in the top 3 elements of A.\nThen we can remove the top 3 elemets of A and the problem is reduced to finding K = 7-K/2 = 4;\nA: 6,10\nB: 2,6,9,13\nK/2 = 2 =\u0026gt; A[1] = 10, B[2] = 9;\nA[1] \u0026gt; B[1]; Remove the top elements of B\nK= 4-2=2\nK/2 = 1\nA: 6,10 B: 9,13 A[0] = 6, B[0]=9\nB[0]\u0026gt;A[0] So we remove A[0]\nA: 10 B: 9,13 K = 2-1 = 1\nNow we can return the smallest one as the answer.\nNote that there will possily be Corner cases\n1.one array is empty, return the kth number of the nonempty array.  2.even number of total elements,we need to find two middle numbers and calculate the median.  3.k may be larger than the length of the smaller array.\ndouble findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int total = nums1.size() + nums2.size(); if (total % 2 != 0) { return findKth(nums1, nums2, total / 2 + 1); } else { return (findKth(nums1, nums2, total / 2) + findKth(nums1, nums2, total / 2 + 1)) *0.5; } } int findKth(vector\u0026lt;int\u0026gt; nums1, vector\u0026lt;int\u0026gt; nums2, int k) { int m = nums1.size(); int n = nums2.size(); if (m \u0026gt; n) return findKth(nums2, nums1, k); if (m == 0) return nums2[k - 1]; if (k == 1) return min(nums1[0], nums2[0]); int i = min(m, k / 2), j = min(n, k / 2); if (nums1[i - 1] \u0026gt; nums2[j - 1]) { return findKth(nums1, vector\u0026lt;int\u0026gt;(nums2.begin() + j, nums2.end()), k - j); } else { return findKth(vector\u0026lt;int\u0026gt;(nums1.begin() + i, nums1.end()), nums2, k - i); } return 0; } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/",
	"title": "Array",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/",
	"title": "Hanswu",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/codingquestions/systemdesign/",
	"title": "SystemDesigns",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/codingquestions/tree/",
	"title": "Trees",
	"tags": [],
	"description": "",
	"content": ""
}]