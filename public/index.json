[
{
	"uri": "http://falcontw.me/codingquestions/",
	"title": "Coding Questions",
	"tags": [],
	"description": "",
	"content": " \nLeetcode / Hackerrank. "
},
{
	"uri": "http://falcontw.me/codingquestions/backtracking/permutation_ii/",
	"title": "Permutation_II",
	"tags": [],
	"description": "",
	"content": " Given a collection of numbers that might contain duplicates, return all possible unique permutations.\nExample: Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ]  Solution 1 In Permutation, we can handle no-duplicated input situation. In this case, we need to prevent from pushing duplicate permutation to result by sorting the array and skipping the same number.\nclassSolution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permuteUnique(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; out, visited(nums.size(), 0); sort(nums.begin(), nums.end()); permuteUniqueDFS(nums, 0, visited, out, res); return res; } void permuteUniqueDFS(vector\u0026lt;int\u0026gt;\u0026amp; nums, int level, vector\u0026lt;int\u0026gt;\u0026amp; visited, vector\u0026lt;int\u0026gt;\u0026amp; out, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; res) { if (level \u0026gt;= nums.size()) {res.push_back(out); return;} for (int i = 0; i \u0026lt; nums.size(); ++i) { if (visited[i] == 1) continue; if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; visited[i - 1] == 0) continue; visited[i] = 1; out.push_back(nums[i]); permuteUniqueDFS(nums, level + 1, visited, out, res); out.pop_back(); visited[i] = 0; } } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/backtracking/permutation/",
	"title": "Permutation",
	"tags": [],
	"description": "",
	"content": " QuestionLink\nGiven a collection of distinct integers, return all possible permutations.\nExample: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]  Solution 1 We use DFS way to enumerate permutation. A \u0026lsquo;visited\u0026rsquo; array is used to denote\nif this number has been visited. And the \u0026lsquo;Level\u0026rsquo; is to represent how far\nhave we dig. We pick one number and push to result if level equals to the\ntarget length.Don\u0026rsquo;t forget to reset the value of the visited array after\nreturn.\nclassSolution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; num) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; out, visited(num.size(), 0); permuteDFS(num, 0, visited, out, res); return res; } void permuteDFS(vector\u0026lt;int\u0026gt;\u0026amp; num, int level, vector\u0026lt;int\u0026gt;\u0026amp; visited, vector\u0026lt;int\u0026gt;\u0026amp; out, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; res) { if (level == num.size()) {res.push_back(out); return;} for (int i = 0; i \u0026lt; num.size(); ++i) { if (visited[i] == 1) continue; visited[i] = 1; out.push_back(num[i]); permuteDFS(num, level + 1, visited, out, res); out.pop_back(); visited[i] = 0; } } };  #Solution 2\nIn another way, we can swap the element each time to derive same result.\nclassSolution { public: void collectPerm(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;result, vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int right) { if (left == right) { vector\u0026lt;int\u0026gt; res; for (auto i : nums) { res.push_back(i); } result.push_back(res); return; } for (int i = left; i \u0026lt;= right; ++i) { swap(nums[i], nums[left]); collectPerm(result, nums, left + 1, right); swap(nums[i], nums[left]); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(nums.begin(), nums.end()); collectPerm(res, nums, 0, nums.size() - 1); return res; } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/dynamicprogramming/minimumpathsum/",
	"title": "MinimumPathSum",
	"tags": [],
	"description": "",
	"content": " QuestionLink\nGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample: Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.  Solution 1 This is a simple dynamic programming problem.\nWe create a 2D array to store the current maximum path sum and return the most right-bottom value.\nclassSolution { public: int minPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(); int n = grid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n,0)); dp[0][0] = grid[0][0]; for (int i = 0; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) { dp[i][j] = grid[i][j]; continue; } else if (i == 0) { dp[i][j] = grid[i][j] + dp[i][j - 1]; } else if (j == 0) { dp[i][j] = grid[i][j] + dp[i - 1][j]; } else { dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } } return dp[m - 1][n - 1]; } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/string/decodestring/",
	"title": "DecodeString",
	"tags": [],
	"description": "",
	"content": " Given an encoded string, return it\u0026rsquo;s decoded string.\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won\u0026rsquo;t be input like 3a or 2[4].\nExamples:\ns = \u0026ldquo;3[a]2[bc]\u0026ldquo;, return \u0026ldquo;aaabcbc\u0026rdquo;. s = \u0026ldquo;3[a2[c]]\u0026ldquo;, return \u0026ldquo;accaccacc\u0026rdquo;. s = \u0026ldquo;2[abc]3[cd]ef\u0026rdquo;, return \u0026ldquo;abcabccdcdcdef\u0026rdquo;.\nSolution 1 This is a traditional recursive problem. We can use stack or recursion to solve.\nWe push parameter for calculation to stack when left bracket appears and pop to calculate while right bracket is met.\n void decode(string \u0026amp;str,int i,int times) { int start = 0; string targetString = \u0026quot;\u0026quot;; while (i \u0026lt; str.size()) { if (str[i] \u0026gt;= '0'\u0026amp;\u0026amp;str[i] \u0026lt;= '9') { string numStr=\u0026quot;\u0026quot;; while (str[i] \u0026gt;= '0'\u0026amp;\u0026amp;str[i] \u0026lt;= '9') { numStr += str[i]; i++; } times = stoi(numStr); decode(str, i, times); i = start; } else if ((str[i] \u0026gt;= 'a'\u0026amp;\u0026amp;str[i] \u0026lt;= 'z') || (str[i] \u0026gt;= 'A'\u0026amp;\u0026amp;str[i] \u0026lt;= 'Z')) { while ((str[i] \u0026gt;= 'a'\u0026amp;\u0026amp;str[i] \u0026lt;= 'z') || (str[i] \u0026gt;= 'A'\u0026amp;\u0026amp;str[i] \u0026lt;= 'Z')) { targetString += str[i]; i++; } } else if (str[i] == '[') { start = i - 1; ++i; } else if (str[i] == ']') { str.replace(start, i-start + 1, \u0026quot;\u0026quot;); string finalString = \u0026quot;\u0026quot;; for (auto index = 0; index \u0026lt; times; ++index) { finalString += targetString; } str.insert(start, finalString); return; } } } string decodeString(string s) { if (s.empty()) { return s; } int i=0; int start=0; int times=0; decode(s,i,times); return s; }  Solution 2 Re-write the stack solution to stack version.\n``` struct decodeParam { int Start = 0; int End = 0; int Times = 0; string TargetString = \u0026ldquo;\u0026rdquo;; }; string decodeString(string str) {\nif (str.empty()) { return str; } stack\u0026lt;decodeParam*\u0026gt; parseStack; int i = 0; while (i \u0026lt; str.size()) { if (str[i] \u0026gt;= '0'\u0026amp;\u0026amp;str[i] \u0026lt;= '9') { decodeParam* param = new decodeParam(); if (!parseStack.empty()) { if (parseStack.top()-\u0026gt;Start == i) { while (str[i] \u0026gt;= '0'\u0026amp;\u0026amp;str[i] \u0026lt;= '9') { ++i; } continue; } } param-\u0026gt;Start = i; string numStr = \u0026quot;\u0026quot;; while (str[i] \u0026gt;= '0'\u0026amp;\u0026amp;str[i] \u0026lt;= '9') { numStr += str[i]; ++i; } param-\u0026gt;Times = stoi(numStr); parseStack.push(param); } else if ((str[i] \u0026gt;= 'a'\u0026amp;\u0026amp;str[i] \u0026lt;= 'z') || (str[i] \u0026gt;= 'A'\u0026amp;\u0026amp;str[i] \u0026lt;= 'Z')) { if (parseStack.empty()) { i++; continue; } string targetStr = \u0026quot;\u0026quot;; while ((str[i] \u0026gt;= 'a'\u0026amp;\u0026amp;str[i] \u0026lt;= 'z') || (str[i] \u0026gt;= 'A'\u0026amp;\u0026amp;str[i] \u0026lt;= 'Z')) { targetStr += str[i]; ++i; } decodeParam* param = parseStack.top(); param-\u0026gt;TargetString = targetStr; } else if (str[i] == '[') { ++i; } else if (str[i] == ']') { decodeParam* param = parseStack.top(); param-\u0026gt;End = i; str.replace(param-\u0026gt;Start, param-\u0026gt;End-param-\u0026gt;Start+1, \u0026quot;\u0026quot;); int times = param-\u0026gt;Times; string finalString = \u0026quot;\u0026quot;; for (auto index = 0; index \u0026lt; times; ++index) { finalString += param-\u0026gt;TargetString; } str.insert(param-\u0026gt;Start, finalString); parseStack.pop(); if (!parseStack.empty()) { i = parseStack.top()-\u0026gt;Start; } else { i = param-\u0026gt;Start + finalString.size(); } } } return str; } ```  "
},
{
	"uri": "http://falcontw.me/codingquestions/array/findpeakelement/",
	"title": "FindPeakElement",
	"tags": [],
	"description": "",
	"content": "Question Link\nA peak element is an element that is greater than its neighbors.\nGiven an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.\nThe array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\nYou may imagine that nums[-1] = nums[n] = -∞.\nExample 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: Input: nums = [1,2,1,3,5,6,4] Output: 1 or 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.  "
},
{
	"uri": "http://falcontw.me/codingquestions/array/numberofislands/",
	"title": "NumberOfIslands",
	"tags": [],
	"description": "",
	"content": "Questions Link\nGiven a 2d grid map of \u0026lsquo;1\u0026rsquo;s (land) and \u0026lsquo;0\u0026rsquo;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nExample 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3  BFS will do. Just like the word search\nclassSolution { public: int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int islandCount=0; for(int i =0;i\u0026lt;grid.size();++i) for(int j=0;j\u0026lt;grid[i].size();++j) { if(grid[i][j]==\u0026#39;1\u0026#39;) { bfsIsland(grid,i,j); ++islandCount; } } return islandCount; } void bfsIsland(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;grid, int i, int j) { if(i\u0026lt;0||j\u0026lt;0||i\u0026gt;grid.size()-1||j\u0026gt;grid[i].size()-1) { return; } if(grid[i][j]==\u0026#39;0\u0026#39;||grid[i][j]==\u0026#39;#\u0026#39;) { return; } if(grid[i][j]==\u0026#39;1\u0026#39;) { grid[i][j]=\u0026#39;#\u0026#39;; } bfsIsland(grid,i+1,j); bfsIsland(grid,i-1,j); bfsIsland(grid,i,j+1); bfsIsland(grid,i,j-1); } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/array/maxareaofislands/",
	"title": "MaxAreaOfIslands",
	"tags": [],
	"description": "",
	"content": " Question Link\nGiven a non-empty 2D array grid of 0\u0026rsquo;s and 1\u0026rsquo;s, an island is a group of 1\u0026rsquo;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nFind the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)\nExample 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally. Example 2: [[0,0,0,0,0,0,0,0]] Given the above grid, return 0. Note: The length of each dimension in the given grid does not exceed 50.  Solution 1 DFS will work. This is a simpler problem of Word Search\nint maxAreaOfIsland(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int maxVal =0; for(int i=0;i\u0026lt;grid.size();++i) for(int j=0;j\u0026lt;grid[i].size();++j) { if(grid[i][j]==1) { maxVal = max(maxVal,areaOfIsland(grid,i,j)); } } return maxVal; } int areaOfIsland(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid, int i, int j) { if(i\u0026gt;=0\u0026amp;\u0026amp;i\u0026lt;grid.size() \u0026amp;\u0026amp; j\u0026gt;=0 \u0026amp;\u0026amp;j\u0026lt;grid[i].size() \u0026amp;\u0026amp; grid[i][j]==1) { grid[i][j]=0; return 1+areaOfIsland(grid,i+1,j)+areaOfIsland(grid,i-1,j) +areaOfIsland(grid,i,j+1)+areaOfIsland(grid,i,j-1); } return 0; } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/search_2d_matrix_2/",
	"title": "Search_2D_Matrix_2",
	"tags": [],
	"description": "",
	"content": " Question Link\nWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\nIntegers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.\nExample: Consider the following matrix: [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] Given target = 5, return true. Given target = 20, return false.  Solution1 The matrix is ascending from left to right, from top to bottom.\nSo we can start from the upper right element to shrink the search space.\nbool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int x = 0; int y = matrix[0].size() - 1; int row = matrix.size(); int col = matrix[0].size(); while (x \u0026lt; row \u0026amp;\u0026amp; y \u0026gt; 0) { if (matrix[x][y] == target) { return true; } else if (matrix[x][y] \u0026gt; target) { y--; } else { x++; } } return false; } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/search_2d_matrix_1/",
	"title": "Search_2D_Matrix_1",
	"tags": [],
	"description": "",
	"content": " Question Link\nWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\nIntegers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.\nExample 1: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true Example 2: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 Output: false  Solution 1 Binary search will do the job.\nbool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); if (target\u0026lt;matrix[0][0] || target \u0026gt; matrix.back().back()) { return false; } int start = 0; int end = m * n - 1; while (start \u0026lt;= end) { int mid = (start + end) / 2; int value = matrix[mid / n][mid%n]; if (value == target) { return true; } else if (value \u0026lt; target) { start = mid + 1; } else { end = mid - 1; } } return false; } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/3sum/",
	"title": "3Sum",
	"tags": [],
	"description": "",
	"content": " Question Link\nGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\nNote:\nThe solution set must not contain duplicate triplets.\nSolution 1 Using pair and hashtable with the same strategy in TwoSum can solve this question too.\nHowever, it will lead to time limit excession in some large cases.\nclassSolution { private: void _parseResult(int leadNumber, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; input) { unordered_set\u0026lt;vector\u0026lt;int\u0026gt;, myVectorHash\u0026gt; result; for (int i = 0; i \u0026lt; input.size(); ++i) { for (auto iterator = input.begin(); iterator != input.end(); ++iterator) { vector\u0026lt;int\u0026gt; output = { leadNumber,iterator-\u0026gt;first,iterator-\u0026gt;second }; result.insert(output); } } for (auto i = result.begin(); i != result.end(); ++i) { totalResult.push_back(*i); } } public: struct myVectorHash { size_t operator()(vector\u0026lt;int\u0026gt;_val)const { return static_cast\u0026lt;size_t\u0026gt;(_val.size() + _val.back() - _val.front()); } }; struct myPairHash { size_t operator()(pair\u0026lt;int, int\u0026gt;_val)const { return static_cast\u0026lt;size_t\u0026gt;((_val.first+10) * 2 + _val.second); } }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; totalResult; const bool isExist = true; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp;nums) { sort(nums.begin(), nums.end()); threeSumHelper(nums); return totalResult; } void threeSumHelper(vector\u0026lt;int\u0026gt;\u0026amp;nums) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairResult; for (int i = 0; i \u0026lt; nums.size(); ++i) { if (i\u0026gt;0 \u0026amp;\u0026amp; nums[i]==nums[i-1]) { continue; } int leadNumber = nums[i]; int target = leadNumber*-1; vector\u0026lt;int\u0026gt; targetVec = vector\u0026lt;int\u0026gt;(nums.begin() + i+1, nums.end()); pairResult = twoSum(targetVec, target); if (!pairResult.empty()) { _parseResult(leadNumber, pairResult); } } } vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_set \u0026lt;pair\u0026lt;int, int\u0026gt;, myPairHash\u0026gt; result; unordered_map\u0026lt;int, int\u0026gt; map; for (int i = 0; i \u0026lt; nums.size(); ++i) { auto iterator = map.find(target - nums[i]); if (iterator == map.end()) { map[nums[i]] = i; } else { result.insert(make_pair(nums[iterator-\u0026gt;second],nums[i])); } } return vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;(result.begin(), result.end()); } };  Solution 2 We sort the array first to keep it in ascending order.\nThen we take every element from the start and find the other two from the next element.\nHere we use dubble pointer to squeeze out the answers, since the whole array is in ascending order.\nWe can avoid doing some dupicate operations.\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(), nums.end()); if (nums.size() \u0026lt; 3) { return result; } for (int i = 0; i \u0026lt; nums.size()-2; ++i) { if(nums[i]\u0026gt;0) { break; } if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1])continue; int start = i + 1; int end = nums.size()-1; while (start \u0026lt; end) { int target = nums[i] * -1; int curSum = nums[start] + nums[end]; if (target == curSum) { vector\u0026lt;int\u0026gt; res; res.push_back(nums[i]); res.push_back(nums[start]); res.push_back(nums[end]); result.push_back(res); ++start; --end; while (nums[start] == nums[start - 1])++start; while (nums[end] == nums[end + 1])--end; } else if (target \u0026gt; curSum) { ++start; while (nums[start] == nums[start - 1])++start; } else { --end; while (nums[end] == nums[end + 1])--end; } } } return result; } "
},
{
	"uri": "http://falcontw.me/codingquestions/string/longestpalindromicsubstring/",
	"title": "LongestPalindromicSubstring",
	"tags": [],
	"description": "",
	"content": " Question Link\nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\nExample 1: Input: \u0026quot;babad\u0026quot; Output: \u0026quot;bab\u0026quot; Note: \u0026quot;aba\u0026quot; is also a valid answer. Example 2: Input: \u0026quot;cbbd\u0026quot; Output: \u0026quot;bb\u0026quot;  Solution1 This is a classic dynamic programming problem.\nWe must figure out what Subproblem and Optimal structure.\nThe optimal solution can derived from every Optimal solution of the subproblems.\nHere we can easily figure out that the Longest palindromic string is related to all the short palindromic string,\nLet P[i,j] = is section [i,j] is a palindrome.\nFor example : S= a b c c b Index = 0 1 2 3 4\nWe can see that\nP[0,0] =1 //each char is a palindrome P[0,1] =S[0] == S[1] , P[1,1] =1 P[0,2] = S[0] == S[2] \u0026amp;\u0026amp; P[1,1], P[1,2] = S[1] == S[2] , P[2,2] = 1 P[0,3] = S[0] == S[3] \u0026amp;\u0026amp; P[1,2], P[1,3] = S[1] == S[3] \u0026amp;\u0026amp; P[2,2] , P[2,3] =S[2] ==S[3], P[3,3]=1\nHere we can conclude these examples to rules.\nP[i,j] = 1 if i ==j = S[i] ==S[j] if j = i+1 = S[i] == S[j] \u0026amp;\u0026amp; P[i+1][j-1] if j\u0026gt;i+1\nstring longestPalindrome(string s) { if (s.size() \u0026lt;= 1) { return s; } int start = 0; int end = 0; int currentMaxLen = 0; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(s.size(), vector\u0026lt;bool\u0026gt;(s.size(), false)); for (int i = 0; i \u0026lt; s.size(); ++i) { for (int j = 0; j \u0026lt; i; ++j) { dp[j][i] = s[i] == s[j] \u0026amp;\u0026amp; (i - j \u0026lt;= 2 || dp[j + 1][i - 1]); if (dp[j][i]) { if (currentMaxLen\u0026lt;i - j + 1) { start = j; end = i; currentMaxLen = i - j + 1; } } } dp[i][i] = true; } return s.substr(start, end-start+1); // Should not replace end-start+1 with currentMaxLen since in case \u0026#34;ac\u0026#34;,currentMaxLen will be zero but still we need one char as answer  } "
},
{
	"uri": "http://falcontw.me/codingquestions/tree/kthsmallestelementinbst/",
	"title": "KthSmallestElementInBST",
	"tags": [],
	"description": "",
	"content": "Questions Link\nGiven a binary search tree, write a function kthSmallest to find the kth smallest element in it.\nNote: You may assume k is always valid, 1 ≤ k ≤ BST\u0026rsquo;s total elements.\nExample 1: Input: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 Output: 3  Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\n##Solution 1\nInorder traverse will do. Pass the k value to each recursive call and return when the\nint kthSmallest(TreeNode* root, int k) { int ans = 0; if (root == NULL) { return 0; } helper(root, k, ans); return ans; } void helper(TreeNode* root, int \u0026amp;k,int \u0026amp;ans) { if (root-\u0026gt;left != NULL) { helper(root-\u0026gt;left, k,ans); } if (k == 0) { ans = root-\u0026gt;val; } k = k - 1; if (root-\u0026gt;right != NULL) { helper(root-\u0026gt;right, k, ans); } }  ##Solution 2 In the followup part, if the BST is modified often, the cost of traversing will be expensive.\nSince the kth smallest element has k-1 nodes in its left-hand side,we may use Divide and Conquer to squeeze out the value.\nint kthSmallest(TreeNode* root, int k) { int count = countNodes(root-\u0026gt;left); if (count == k - 1) { return root-\u0026gt;val; } else if (count \u0026lt; k - 1) { return kthSmallest(root-\u0026gt;right,k-count-1 ); } else { return kthSmallest(root-\u0026gt;left, k); } } int countNodes(TreeNode* root) { if (root == NULL) { return 0; } return 1 + countNodes(root-\u0026gt;left) + countNodes(root-\u0026gt;right); } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/wordsearch/",
	"title": "WordSearch",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \u0026quot;ABCCED\u0026quot;, return true. Given word = \u0026quot;SEE\u0026quot;, return true. Given word = \u0026quot;ABCB\u0026quot;, return false.  Solution 1 We need to start from everypoint and search in four directions to check if there is word matched, in this way,\nwe apply DFS and backtracking to this problem, and initialize a \u0026lsquo;visited\u0026rsquo; array to keep recording where this entry is visited\nfor traversing the whole board.\nbool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { if (board.empty() || board[0].empty()) { return false; } vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(board.size(), vector\u0026lt;bool\u0026gt;(board[0].size(), false)); for (int i = 0; i\u0026lt;board.size(); ++i) { for (int j = 0; j\u0026lt;board[0].size(); ++j) { if (searchWord(board,word,0,i, j, visited)) { return true; } } } return false; } bool searchWord(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board,string word,int idx,int i, int j, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; \u0026amp;visited) { if (idx == word.size()) { return true; } if (i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt; board.size() - 1 || j \u0026gt; board[0].size() - 1 || visited[i][j] || board[i][j] != word[idx]) { return false; } visited[i][j] = true; bool res = searchWord(board, word, idx + 1, i - 1, j, visited) || searchWord(board, word, idx + 1, i + 1, j, visited) || searchWord(board, word, idx + 1, i, j - 1, visited) || searchWord(board, word, idx + 1, i, j + 1, visited); visited[i][j] = false; return res; }  Solution 2 Or otherwise , we may just modify the visited board entry and restore it afterwards, then we don\u0026rsquo;t need additional visited array.\nbool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { if (board.empty() || board[0].empty()) { return false; } vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(board.size(), vector\u0026lt;bool\u0026gt;(board[0].size(), false)); for (int i = 0; i\u0026lt;board.size(); ++i) { for (int j = 0; j\u0026lt;board[0].size(); ++j) { if (searchWord(board,word,0,i, j, visited)) { return true; } } } return false; } bool searchWord(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board,string word,int idx,int i, int j, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; \u0026amp;visited) { if (idx == word.size()) { return true; } if (i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt; board.size() - 1 || j \u0026gt; board[0].size() - 1 || board[i][j] != word[idx]) { return false; } char c = board[i][j]; board[i][j] = \u0026#39;#\u0026#39;; bool res = searchWord(board, word, idx + 1, i - 1, j, visited) || searchWord(board, word, idx + 1, i + 1, j, visited) || searchWord(board, word, idx + 1, i, j - 1, visited) || searchWord(board, word, idx + 1, i, j + 1, visited); board[i][j] = c; return res; } "
},
{
	"uri": "http://falcontw.me/codingquestions/systemdesign/lru_cache/",
	"title": "LRU Cache",
	"tags": [],
	"description": "",
	"content": " Questions Link\nDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\nput(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity,\nit should invalidate the least recently used item before inserting a new item.\nFollow up: Could you do both operations in O(1) time complexity?\nExample:\nLRUCache cache = new LRUCache( 2 /* capacity */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4  Solution Using hashtable -\u0026gt; TLE Using input key as the key of the map and the value is composed of the value and a time stamp.\nThe least being used is the value, the smaller is the time stamp.\nget(int key) : Set time of target entry to 0, and the time of the rest entries are deducted by one.  put(int key) : If capacity is not yet full,insert the key and value, set time to zero, or delete the entry with the smallest time and insert the new one.  Time complexity is O(1) when getting value but deducting time is time wasting that leads to TLE.\nUsing Linkedlist -\u0026gt;TLE Search for target entry is time wasting, not O(1).\nUsing DoublyLinkedlist + Hashtable Double-linked list along with Hashtable can ensure all the operations are O(1) complexity;\nWhen we are trying to get the value, we visit the map, if there is need to modify the doubly linkedlist,\nwe don\u0026rsquo;t need to search from the very beginning.\nstruct LRUElement { int key; int value; LRUElement* prev; LRUElement* next; LRUElement() :key(0), value(0), prev(NULL), next(NULL) {}; }; classLRUCache { private: int _capacity; int _count; LRUElement* head; LRUElement* tail; unordered_map\u0026lt;int, LRUElement*\u0026gt; map; void _DetachNode(LRUElement* node) { node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; } void _MoveToFront(LRUElement* node) { node-\u0026gt;next = head-\u0026gt;next; node-\u0026gt;prev = head; head-\u0026gt;next = node; node-\u0026gt;next-\u0026gt;prev = node; } void _RemoveTailNode() { LRUElement* node = tail-\u0026gt;prev; _DetachNode(node); map.erase(node-\u0026gt;key); --_count; } public: LRUCache(int capacity) { _capacity = capacity; _count = 0; head = new LRUElement(); tail = new LRUElement(); head-\u0026gt;prev = NULL; head-\u0026gt;next = tail; tail-\u0026gt;prev = head; tail-\u0026gt;next = NULL; } int get(int key) { if (map.find(key) == map.end()) { return -1; } else { LRUElement* node = map[key]; _DetachNode(node); _MoveToFront(node); return node-\u0026gt;value; } } void put(int key, int value) { if (map.find(key)==map.end()) { LRUElement* node = new LRUElement(); if (_count == _capacity) { _RemoveTailNode(); } node -\u0026gt; key = key; node-\u0026gt;value = value; map[key] = node; _MoveToFront(node); ++_count; } else { LRUElement* node = map[key]; _DetachNode(node); node-\u0026gt;value = value; _MoveToFront(node); } } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/tree/binarytreelevelorder/",
	"title": "BinaryTreeLevelOrder",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven a binary tree, return the level order traversal of its nodes\u0026rsquo; values. (ie, from left to right, level by level).\nFor example: Given binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ]  Solution 1 BFS is the one of the most common ways to solve this questions.\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; totalResult; if (root == NULL) { return totalResult; } queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); while (!q.empty()) { int size = q.size(); vector\u0026lt;int\u0026gt; res; for (int i = 0; i \u0026lt; size; ++i) { TreeNode* node = q.front(); res.push_back(node-\u0026gt;val); q.pop(); if (node-\u0026gt;left) { q.push(node-\u0026gt;left); } if (node-\u0026gt;right) { q.push(node-\u0026gt;right); } } totalResult.push_back(res); } return totalResult; } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/sortcolors/",
	"title": "SortColors",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\nNote: You are not suppose to use the library\u0026rsquo;s sort function for this problem.\nExample: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up:  A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0\u0026rsquo;s, 1\u0026rsquo;s, and 2\u0026rsquo;s, then overwrite array with total number of 0\u0026rsquo;s, then 1\u0026rsquo;s and followed by 2\u0026rsquo;s. Could you come up with a one-pass algorithm using only constant space?\nSolution 1 The two pass method is simple. We may just try to record the times each number appears.\nAnd restore the numbers back to the result.\nclassSolution { public: void sortColors(int A[], int n) { int count[3] = {0}, idx = 0; for (int i = 0; i \u0026lt; n; ++i) ++count[A[i]]; for (int i = 0; i \u0026lt; 3; ++i) { for (int j = 0; j \u0026lt; count[i]; ++j) { A[idx++] = i; } } } };  Solution 2 Since the order is not strictly ascending,so we don\u0026rsquo;t really need to sort the whole array,\nwhat we need to come to in mind is the method in Quick sort which helps to partition the array\naccording to the chosen pivot.\nvoid sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int left =0; int right =nums.size()-1; int pivot=0; while(left\u0026lt;=right) { if(nums[left]==2) { swap(nums[left],nums[right--]); } else if(nums[left]==0) { swap(nums[left++],nums[pivot++]); } else { left++; } } } "
},
{
	"uri": "http://falcontw.me/codingquestions/tree/validatebst/",
	"title": "ValidateBST",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.  Example 1: Input: 2 / \\ 1 3 Output: true  To validate a Binary Search Tree, we can either utilize its property to validate\nor we can have inorder traverse to see if the previous element is smaller than current one,\nif not, that implies this BST is invalid.\nSolution 1 We validate each node of the tree to see if it meets with the property.\nclassSolution { public: bool isValidBST(TreeNode* root) { return checkValidBST(root,LONG_MIN,LONG_MAX); } bool checkValidBST(TreeNode* root,long min,long max) { if(root==NULL) { return true; } if(root-\u0026gt;val \u0026lt;= min || root-\u0026gt;val \u0026gt;=max) { return false; } return checkValidBST(root-\u0026gt;left,min,root-\u0026gt;val) \u0026amp;\u0026amp; checkValidBST(root-\u0026gt;right,root-\u0026gt;val,max); } };  Solution 2 We traverse the whole tree with inorder and see if the prev element is always smaller than current one.\nclassSolution { public: bool isValidBST(TreeNode* root) { long prev = LONG_MIN; return inorderTraverse(root,prev); } bool inorderTraverse(TreeNode* root, long\u0026amp; prev) { if(root==NULL) { return true; } if(!inorderTraverse(root-\u0026gt;left,prev)) { return false; } if(prev \u0026gt;=root-\u0026gt;val) { return false; } prev = root-\u0026gt;val; if(!inorderTraverse(root-\u0026gt;right,prev)) { return false; } return true; } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/array/wigglesort2/",
	"title": "WiggleSort II",
	"tags": [],
	"description": "",
	"content": " Questions Link\nGiven an unsorted array nums, reorder it such that nums[0] \u0026lt; nums[1] \u0026gt; nums[2] \u0026lt; nums[3]\u0026hellip;.\nExample 1: Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. Example 2: Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2].  Solution Sol A:\nTo make the array wiggle like, Stefan Pochmann \u0026rsquo;s post\nintroduced a way called virtual indexing to reorder the map position and the index itself.\nConsider\nA(i) = nums[(2*i+1)/(n|1)]  This helps us to recorder the element and mapping with wiggle order.\n A(0) – \u0026gt; nums[1] A(1) – \u0026gt; nums[3] A(2) – \u0026gt; nums[5] A(3) – \u0026gt; nums[7] A(4) – \u0026gt; nums[9] A(5) – \u0026gt; nums[0] A(6) – \u0026gt; nums[2] A(7) – \u0026gt; nums[4] A(8) – \u0026gt; nums[6] A(9) – \u0026gt; nums[8]  Our target is to make the 1,3,5,7,\u0026hellip; elements always bigger than the 0,2,4,6,8 elements.\nThen let\u0026rsquo;s focus on the A(i) array, in the new A(i) array, we need to place the ones bigger than the median starting from the front\nand place the ones smaller than the median from the last position. In this way, we can ensure the odd-indexed elemnt is always larger\nthan the even-indexed element. To acheive this, we can refer to the Sort color; problem\nclassSolution { public: int newIndex(int index, int n) { return (1 + 2 * index) % (n | 1); } void wiggleSort(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int size = nums.size(); int front = 0; int mid = (size+1) / 2; int pos = 0; nth_element(nums.begin(), nums.begin() + mid, nums.end()); // Quick select to partition the array base on given pivot  int left = 0, i = 0, right = size - 1; int median = nums[mid]; while (i \u0026lt;= right) // Sort color  { if (nums[newIndex(i,size)] \u0026gt; median) { swap(nums[newIndex(left++,size)], nums[newIndex(i++,size)]); } else if (nums[newIndex(i,size)] \u0026lt; median) { swap(nums[newIndex(right--,size)], nums[newIndex(i,size)]); } else { i++; } } } }; "
},
{
	"uri": "http://falcontw.me/codingquestions/array/median_of_two_sorted_array_with_different_size/",
	"title": "Median of 2 sorted array",
	"tags": [],
	"description": "",
	"content": " Questions Link\nExample 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty.  Solution This is indeed an kth smalleset element questions. The kth value turns to be median in this case.\nSince we need to implement this within logarithmic time. We need to take advantage of Binary Search.\nThe point is that it\u0026rsquo;s not what is left but what we delete matters.\nSuppose there is two array called A and B.\nA: 1,3,5,6,10.\nB: 2,6,9,13\nand we wanna find the 7th element.\n7\u0026frasl;2 =3, So we take out the 3th element from A and B.\nA[2] = 5, B[2] =9\nHere we can see that B[2]\u0026gt;A[2] which means the 7th elements won\u0026rsquo;t be in the top 3 elements of A.\nThen we can remove the top 3 elemets of A and the problem is reduced to finding K = 7-K/2 = 4;\nA: 6,10\nB: 2,6,9,13\nK/2 = 2 =\u0026gt; A[1] = 10, B[2] = 9;\nA[1] \u0026gt; B[1]; Remove the top elements of B\nK= 4-2=2\nK/2 = 1\nA: 6,10 B: 9,13 A[0] = 6, B[0]=9\nB[0]\u0026gt;A[0] So we remove A[0]\nA: 10 B: 9,13 K = 2-1 = 1\nNow we can return the smallest one as the answer.\nNote that there will possily be Corner cases\n1.one array is empty, return the kth number of the nonempty array.  2.even number of total elements,we need to find two middle numbers and calculate the median.  3.k may be larger than the length of the smaller array.\ndouble findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int total = nums1.size() + nums2.size(); if (total % 2 != 0) { return findKth(nums1, nums2, total / 2 + 1); } else { return (findKth(nums1, nums2, total / 2) + findKth(nums1, nums2, total / 2 + 1)) *0.5; } } int findKth(vector\u0026lt;int\u0026gt; nums1, vector\u0026lt;int\u0026gt; nums2, int k) { int m = nums1.size(); int n = nums2.size(); if (m \u0026gt; n) return findKth(nums2, nums1, k); if (m == 0) return nums2[k - 1]; if (k == 1) return min(nums1[0], nums2[0]); int i = min(m, k / 2), j = min(n, k / 2); if (nums1[i - 1] \u0026gt; nums2[j - 1]) { return findKth(nums1, vector\u0026lt;int\u0026gt;(nums2.begin() + j, nums2.end()), k - j); } else { return findKth(vector\u0026lt;int\u0026gt;(nums1.begin() + i, nums1.end()), nums2, k - i); } return 0; } "
},
{
	"uri": "http://falcontw.me/codingquestions/array/",
	"title": "Array",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/codingquestions/backtracking/",
	"title": "BackTrackings",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/codingquestions/dynamicprogramming/",
	"title": "DynamicProgrammings",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/",
	"title": "Hanswu",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/codingquestions/string/",
	"title": "Strings",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/codingquestions/systemdesign/",
	"title": "SystemDesigns",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://falcontw.me/codingquestions/tree/",
	"title": "Trees",
	"tags": [],
	"description": "",
	"content": ""
}]